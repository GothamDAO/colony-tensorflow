{"version":3,"sources":["../../src/classes/ContractMethodSender.js"],"names":["ContractMethodSender","defaultGasLimit","eventHandlers","rest","_defaultGasLimit","inputValues","args","getValidatedArgs","client","estimate","functionName","options","_send","transaction","timeoutMs","getEventData","events","transactionHash","hash","eventData","_waitForTransactionReceipt","receipt","successful","status","meta","eventDataPromise","receiptPromise","successfulPromise","Promise","resolve","reject","toString","callArgs","_getDefaultSendOptions","waitForMining","transactionOptions","_sendTransaction","_sendWithWaitingForMining","_sendWithoutWaitingForMining","send","adapter","getTransactionReceipt","waitForTransaction","networkName","provider","name","minutes","Object","assign","gasLimit"],"mappings":"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","file":"ContractMethodSender.js","sourcesContent":["/* @flow */\n\nimport BigNumber from 'bn.js';\nimport { raceAgainstTimeout } from '@colony/colony-js-utils';\n\nimport type {\n  EventHandlers,\n  Transaction,\n  TransactionOptions,\n} from '@colony/colony-js-adapter';\n\nimport ContractClient from './ContractClient';\nimport ContractMethod from './ContractMethod';\nimport type {\n  ContractResponse,\n  ContractMethodArgs,\n  SendOptions,\n} from '../flowtypes';\n\nexport default class ContractMethodSender<\n  InputValues: { [inputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> extends ContractMethod<InputValues, OutputValues, IContractClient> {\n  eventHandlers: EventHandlers;\n  _defaultGasLimit: ?number;\n\n  constructor({\n    defaultGasLimit,\n    eventHandlers,\n    ...rest\n  }: ContractMethodArgs<IContractClient> & {\n    eventHandlers?: EventHandlers,\n    defaultGasLimit?: number,\n  }) {\n    super(rest);\n    if (defaultGasLimit) this._defaultGasLimit = defaultGasLimit;\n    if (eventHandlers) this.eventHandlers = eventHandlers;\n  }\n\n  /**\n   * Given named input values, call the method's contract function in\n   * order to get a gas estimate for calling it with those values.\n   */\n  async estimate(inputValues: InputValues): Promise<BigNumber> {\n    const args = this.getValidatedArgs(inputValues);\n    return this.client.estimate(this.functionName, args);\n  }\n\n  /**\n   * Given named input values and options for sending a transaction, create a\n   * transaction which calls the method's contract function with those\n   * values as transformed parameters, and collect the transaction receipt\n   * and (optionally) event data.\n   */\n  async send(\n    inputValues: InputValues,\n    options: SendOptions,\n  ): Promise<ContractResponse<OutputValues>> {\n    const args = this.getValidatedArgs(inputValues);\n    return this._send(args, options);\n  }\n\n  async _sendWithWaitingForMining(\n    transaction: Transaction,\n    timeoutMs: number,\n  ): Promise<ContractResponse<OutputValues>> {\n    const eventData = await this.client.getEventData({\n      events: this.eventHandlers,\n      timeoutMs,\n      transactionHash: transaction.hash,\n    });\n    const receipt = await raceAgainstTimeout(\n      this._waitForTransactionReceipt(transaction.hash),\n      timeoutMs,\n    );\n\n    return {\n      successful: receipt && receipt.status === 1,\n      meta: {\n        transaction,\n        receipt,\n      },\n      eventData,\n    };\n  }\n\n  _sendWithoutWaitingForMining(\n    transaction: Transaction,\n    timeoutMs: number,\n  ): ContractResponse<OutputValues> {\n    const eventDataPromise = this.client.getEventData({\n      events: this.eventHandlers,\n      timeoutMs,\n      transactionHash: transaction.hash,\n    });\n    const receiptPromise = raceAgainstTimeout(\n      this._waitForTransactionReceipt(transaction.hash),\n      timeoutMs,\n    );\n    const successfulPromise = new Promise(async (resolve, reject) => {\n      try {\n        const receipt = await receiptPromise;\n        resolve(receipt && receipt.status === 1);\n      } catch (error) {\n        reject(error.toString());\n      }\n    });\n    return {\n      successfulPromise,\n      meta: {\n        receiptPromise,\n        transaction,\n      },\n      eventDataPromise,\n    };\n  }\n\n  async _send(\n    callArgs: Array<any>,\n    options: SendOptions,\n  ): Promise<ContractResponse<OutputValues>> {\n    const {\n      timeoutMs,\n      waitForMining,\n      ...transactionOptions\n    } = this._getDefaultSendOptions(options);\n\n    const transaction = await this._sendTransaction(\n      callArgs,\n      transactionOptions,\n    );\n\n    return waitForMining\n      ? this._sendWithWaitingForMining(transaction, timeoutMs)\n      : this._sendWithoutWaitingForMining(transaction, timeoutMs);\n  }\n\n  async _sendTransaction(\n    callArgs: Array<any>,\n    transactionOptions: TransactionOptions,\n  ) {\n    return this.client.send(this.functionName, callArgs, transactionOptions);\n  }\n\n  async _waitForTransactionReceipt(transactionHash: string) {\n    // Firstly attempt to get the receipt immediately; the transaction\n    // may be running on TestRPC with no mining time.\n    const receipt = await this.client.adapter.getTransactionReceipt(\n      transactionHash,\n    );\n    if (receipt != null) return receipt;\n\n    // Failing that, wait until the transaction has been mined.\n    await this.client.adapter.waitForTransaction(transactionHash);\n    return this.client.adapter.getTransactionReceipt(transactionHash);\n  }\n\n  /**\n   * Given send options, set default values for this Sender.\n   */\n  _getDefaultSendOptions(options: SendOptions) {\n    const { name: networkName } = this.client.adapter.provider;\n    // Allow a much longer timeout for mainnet transactions.\n    const minutes = networkName === 'mainnet' ? 60 : 5;\n\n    return Object.assign(\n      {},\n      {\n        timeoutMs: 1000 * 60 * minutes,\n        waitForMining: true,\n        ...(this._defaultGasLimit ? { gasLimit: this._defaultGasLimit } : null),\n      },\n      options,\n    );\n  }\n}\n"]}