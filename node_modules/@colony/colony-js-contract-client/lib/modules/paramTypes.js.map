{"version":3,"sources":["../../src/modules/paramTypes.js"],"names":["addParamType","passThrough","value","PARAM_TYPE_MAP","address","validate","convertOutput","convertInput","bigNumber","Number","isFinite","boolean","date","Date","valueOf","converted","parseInt","toNumber","setMilliseconds","hexString","number","Boolean","string","length","ipfsHash","slice","hex","bytes","encode","decode","toString","tokenAddress","typeMapFn","fnName","type","fn","def","Object","assign","validateValueType","bind","convertOutputValue","convertInputValue"],"mappings":"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","file":"paramTypes.js","sourcesContent":["/* @flow */\n\nimport bs58 from 'bs58';\nimport BigNumber from 'bn.js';\nimport {\n  isHex,\n  isHexStrict,\n  utf8ToHex,\n  hexToBytes,\n  hexToUtf8,\n  toHex,\n} from 'web3-utils';\nimport {\n  isValidAddress,\n  isBigNumber,\n  isEmptyHexString,\n} from '@colony/colony-js-utils';\n\nimport type { ParamTypes, ParamTypeDef } from '../flowtypes';\nimport { isBoolean } from './paramValidation';\n\nconst passThrough = value => value;\n\n/**\n * A map of ParamTypes to ParamTypeDefs\n * For each ParamType (e.g. address), defines how a value should be validated\n * or converted for input/output.\n */\nconst PARAM_TYPE_MAP: {\n  [type: ParamTypes]: ParamTypeDef,\n} = {\n  address: {\n    validate: isValidAddress,\n    convertOutput(value) {\n      return isValidAddress(value) ? value : null;\n    },\n    convertInput: passThrough,\n  },\n  bigNumber: {\n    validate: isBigNumber,\n    convertOutput(value: any) {\n      if (isBigNumber(value)) {\n        return value;\n      } else if (Number.isFinite(value)) {\n        return new BigNumber(value);\n      }\n      return null;\n    },\n    convertInput: passThrough,\n  },\n  boolean: {\n    validate: isBoolean,\n    convertOutput(value) {\n      return isBoolean(value) ? value : null;\n    },\n    convertInput: passThrough,\n  },\n  date: {\n    validate(value: any) {\n      return value instanceof Date && !!value.valueOf();\n    },\n    convertOutput(value: any) {\n      const converted = parseInt(\n        isBigNumber(value) ? value.toNumber() : value,\n        10,\n      );\n      // Recreate the date by adding milliseconds to the timestamp\n      return converted > 0 ? new Date(converted * 1000) : null;\n    },\n    convertInput(value: Date) {\n      // Dates are stored as timestamps without milliseconds\n      return parseInt(value.setMilliseconds(0) / 1000, 10);\n    },\n  },\n  hexString: {\n    validate(value: any) {\n      return isHexStrict(value);\n    },\n    convertOutput(value: any) {\n      return toHex(value);\n    },\n    convertInput: passThrough,\n  },\n  number: {\n    validate(value: any) {\n      return Boolean(Number.isFinite(value));\n    },\n    convertOutput(value: any) {\n      const converted = isBigNumber(value) ? value.toNumber() : value;\n      return Number.isFinite(converted) ? converted : null;\n    },\n    convertInput: passThrough,\n  },\n  string: {\n    validate(value: any) {\n      return typeof value === 'string';\n    },\n    convertOutput(value: any) {\n      if (isHexStrict(value)) {\n        return isEmptyHexString(value) ? null : hexToUtf8(value);\n      }\n      return typeof value === 'string' && value.length ? value : null;\n    },\n    convertInput(value: string) {\n      // String values are converted to hex (if they aren't hex already)\n      return isHex(value) ? value : utf8ToHex(value);\n    },\n  },\n  ipfsHash: {\n    validate(value: any) {\n      return (\n        typeof value === 'string' &&\n        value.slice(0, 2) === 'Qm' &&\n        value.length === 46\n      );\n    },\n    convertOutput(value: any) {\n      if (isHexStrict(value) && !isEmptyHexString(value)) {\n        const hex = `0x1220${value.slice(2)}`;\n        const bytes = hexToBytes(hex);\n        return bs58.encode(bytes);\n      }\n      return null;\n    },\n    convertInput(value: string) {\n      return `0x${bs58\n        .decode(value)\n        .slice(2)\n        .toString('hex')}`;\n    },\n  },\n  // Either a valid address, or an empty address to indicate ether\n  // (0x0 or 0x0000000000000000000000000000000000000000)\n  tokenAddress: {\n    validate(value: any) {\n      return isValidAddress(value) || isEmptyHexString(value);\n    },\n    convertInput(value: string) {\n      return value;\n    },\n    convertOutput(value: string) {\n      return value;\n    },\n  },\n};\n\n/**\n * Given the key of a ParamTypeDef (namely `validate`, `convertOutput` or\n * `convertInput`), a value and ParamType, pluck the appropriate function\n * from the type map and call it with the value.\n */\nfunction typeMapFn(fnName: $Keys<ParamTypeDef>, value: any, type: ParamTypes) {\n  const {\n    [type]: { [fnName]: fn },\n  } = PARAM_TYPE_MAP;\n  return fn(value);\n}\n\nexport function addParamType(type: string, def: ParamTypeDef): void {\n  Object.assign(PARAM_TYPE_MAP, { [type]: def });\n}\n\n/**\n * Given a value and a ParamType, validate the value according to that type's\n * `validate` function\n */\nexport const validateValueType = typeMapFn.bind(this, 'validate');\n\n/**\n * Given a value and a ParamType, convert the value according to that type's\n * `convertOutput` function\n */\nexport const convertOutputValue = typeMapFn.bind(this, 'convertOutput');\n\n/**\n * Given a value and a ParamType, convert the value according to that type's\n * `convertInput` function\n */\nexport const convertInputValue = typeMapFn.bind(this, 'convertInput');\n"]}